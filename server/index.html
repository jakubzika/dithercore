<!DOCTYPE html>
<html>

<head>
    <title>WebCam to NodeMCU Display</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        canvas {
            border: 1px solid #ccc;
            margin: 10px;
            image-rendering: pixelated;
        }

        video {
            border: 1px solid #ccc;
            margin: 10px;
        }

        textarea {
            width: 100%;
            height: 150px;
            font-family: monospace;
        }

        button {
            padding: 15px 25px;
            margin: 10px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:active {
            background-color: #004085;
        }

        #flipCameraBtn {
            background-color: #28a745;
            display: none;
        }

        #flipCameraBtn:hover {
            background-color: #218838;
        }

        #flipCameraBtn:active {
            background-color: #1e7e34;
        }

        .button-row {
            margin: 10px 0;
        }

        .container {
            text-align: center;
        }

        .status {
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .connected {
            background-color: #d4edda;
            color: #155724;
        }

        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }

        #preview {
            display: none;
        }

        #dithered {
            width: 256px;
            height: 256px;
        }
    </style>
</head>

<body>
    <h1>WebCam to NodeMCU Display</h1>
    <div class="container">

        <video id="webcam" width="256" height="256" autoplay muted playsinline></video>
        <canvas id="preview" width="128" height="128"></canvas>
        <canvas id="dithered" width="128" height="128"></canvas><br>
        <div id="status" class="status disconnected">WebSocket: Disconnected</div>

        <div class="button-row">
            <button id="flipCameraBtn" onclick="flipCamera()">Flip Camera</button>
        </div>
        <div class="button-row">
            <button onclick="startWebcam()">Start WebCam</button>
            <button onclick="stopWebcam()">Stop WebCam</button>
            <button onclick="connectWebSocket()">Connect WebSocket</button>
            <button onclick="toggleStreaming()">Start Streaming</button>
        </div>
    </div>

    <h3>Base64 Output:</h3>
    <textarea id="base64Output" readonly></textarea>

    <script>
        let webcamStream = null;
        let ws = null;
        let streaming = false;
        let streamInterval = null;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let cameras = [];

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('preview');
        const ctx = canvas.getContext('2d');
        const ditheredCanvas = document.getElementById('dithered');
        const ditheredCtx = ditheredCanvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const flipCameraBtn = document.getElementById('flipCameraBtn');

        const searchParam = new URLSearchParams(window.location.search)

        async function start() {
            await connectWebSocket();
            await startWebcam()
            toggleStreaming()
        }

        let base64Data = '';

        window.addEventListener('load', async () => {
            // Check for available cameras
            await checkCameras();

            if (searchParam.get('autoplay') == 'false') {
                console.log('no autplay')
            } else {
                console.log('autoplay')
                start()
            }
        })

        async function checkCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                console.log(devices)
                cameras = devices.filter(device => device.kind === 'videoinput');

                // Show flip button only if there are multiple cameras
                if (cameras.length > 1) {
                    console.log('more cams detected')
                    flipCameraBtn.style.display = 'inline-block';
                } else {
                    console.log('no more cams')
                }
            } catch (error) {
                console.error('Error checking cameras:', error);
            }
        }

        async function startWebcam() {
            try {
                const constraints = {
                    video: {
                        width: 300,
                        height: 300,
                        aspectRatio: 1.0,
                        facingMode: currentFacingMode
                    }
                };

                // Stop existing stream if any
                if (webcamStream) {
                    webcamStream.getTracks().forEach(track => track.stop());
                }

                webcamStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = webcamStream;
            } catch (error) {
                // If facingMode fails, try without it
                try {
                    webcamStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 300,
                            height: 300,
                            aspectRatio: 1.0
                        }
                    });
                    video.srcObject = webcamStream;
                } catch (fallbackError) {
                    alert('Error accessing webcam: ' + fallbackError.message);
                }
            }
        }

        async function flipCamera() {
            if (!webcamStream) {
                alert('Please start webcam first!');
                return;
            }

            // Toggle facing mode
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';

            // Restart webcam with new facing mode
            await startWebcam();
        }

        function stopWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
                video.srcObject = null;
            }
            if (streaming) toggleStreaming();
        }

        function connectWebSocket() {
            return new Promise((res, rej) => {
                if (ws && ws.readyState === WebSocket.OPEN) return;

                const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
                // const protocol = 'wss'
                // const host = 'dithercore.jakubzika.com'
                const host = window.location.host
                const wsUrl = `${protocol}://${host}/upload`;
                console.log(wsUrl)

                ws = new WebSocket(wsUrl);

                ws.onopen = function () {
                    statusDiv.textContent = 'WebSocket: Connected';
                    statusDiv.className = 'status connected';
                    res()
                };

                ws.onclose = function () {
                    statusDiv.textContent = 'WebSocket: Disconnected';
                    statusDiv.className = 'status disconnected';
                    if (streaming) toggleStreaming();
                };

                ws.onerror = function (error) {
                    console.error('WebSocket error:', error);
                    rej()
                };
            })
        }

        function captureAndProcess() {
            if (!webcamStream) return;

            // Draw webcam frame to preview canvas (square crop from center)
            const videoAspect = video.videoWidth / video.videoHeight;
            let sx, sy, sWidth, sHeight;

            if (videoAspect > 1) {
                // Wider than tall - crop sides
                sHeight = video.videoHeight;
                sWidth = sHeight;
                sx = (video.videoWidth - sWidth) / 2;
                sy = 0;
            } else {
                // Taller than wide - crop top/bottom
                sWidth = video.videoWidth;
                sHeight = sWidth;
                sx = 0;
                sy = (video.videoHeight - sHeight) / 2;
            }

            ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, 128, 128);

            // Process the image
            processImage();
        }

        function processImage() {
            const imageData = ctx.getImageData(0, 0, 128, 128);
            const pixels = imageData.data;

            // Convert to grayscale
            for (let i = 0; i < pixels.length; i += 4) {
                const gray = pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114;
                pixels[i] = pixels[i + 1] = pixels[i + 2] = gray;
            }

            // Histogram normalization
            let min = 255, max = 0;
            // Find min and max values
            for (let i = 0; i < pixels.length; i += 4) {
                const value = pixels[i];
                if (value < min) min = value;
                if (value > max) max = value;
            }

            // Normalize to full 0-255 range
            const range = max - min;
            if (range > 0) {
                for (let i = 0; i < pixels.length; i += 4) {
                    const normalized = ((pixels[i] - min) / range) * 255;
                    pixels[i] = pixels[i + 1] = pixels[i + 2] = normalized;
                }
            }

            // Floyd-Steinberg dithering
            for (let y = 0; y < 128; y++) {
                for (let x = 0; x < 128; x++) {
                    const idx = (y * 128 + x) * 4;
                    const oldPixel = pixels[idx];
                    const newPixel = oldPixel < 128 ? 0 : 255;
                    pixels[idx] = pixels[idx + 1] = pixels[idx + 2] = newPixel;

                    const error = oldPixel - newPixel;

                    if (x < 127) {
                        pixels[idx + 4] += error * 7 / 16;
                    }
                    if (y < 127) {
                        if (x > 0) pixels[idx + 128 * 4 - 4] += error * 3 / 16;
                        pixels[idx + 128 * 4] += error * 5 / 16;
                        if (x < 127) pixels[idx + 128 * 4 + 4] += error * 1 / 16;
                    }
                }
            }

            ditheredCtx.putImageData(imageData, 0, 0);

            // Convert to XBM format
            const xbmData = new Uint8Array(2048);
            for (let y = 0; y < 128; y++) {
                for (let x = 0; x < 128; x += 8) {
                    let byte = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        const idx = (y * 128 + x + bit) * 4;
                        if (pixels[idx] === 255) {
                            byte |= (1 << bit);
                        }
                    }
                    xbmData[y * 16 + Math.floor(x / 8)] = byte;
                }
            }

            base64Data = btoa(String.fromCharCode.apply(null, xbmData));
            document.getElementById('base64Output').value = base64Data;
        }

        function sendFrame() {
            if (ws && ws.readyState === WebSocket.OPEN && base64Data) {
                ws.send(JSON.stringify({
                    type: 'frame',
                    data: base64Data,
                    timestamp: Date.now()
                }));
            }
        }

        function toggleStreaming() {
            if (!streaming) {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    alert('Please connect WebSocket first!');
                    return;
                }
                if (!webcamStream) {
                    alert('Please start webcam first!');
                    return;
                }

                streaming = true;
                streamInterval = setInterval(() => {
                    captureAndProcess();
                    sendFrame();
                }, 1000);

                document.querySelector('button[onclick="toggleStreaming()"]').textContent = 'Stop Streaming';
            } else {
                streaming = false;
                if (streamInterval) {
                    clearInterval(streamInterval);
                    streamInterval = null;
                }
                document.querySelector('button[onclick="toggleStreaming()"]').textContent = 'Start Streaming';
            }
        }

        // Auto-connect WebSocket on page load
    </script>
</body>

</html>